# github notes 1

[github work guide 1](github-work-guide-1.md)

> References
> <https://github.com/Financial-Times/upp-docs/blob/master/guides/git-guide/README.md>

---

[gitconfig example 1](gitconfig-1.md)

---

## Global gitignore

|||global gitignore

[.gitignore example 1](gitignore-1.md)

> References
>
> <https://stackoverflow.com/questions/7335420/global-git-ignore/22885996#22885996>

```text
You need to set up your global core.excludesfile configuration file to point to this global ignore file.

e.g.

*nix or Windows git bash:

git config --global core.excludesFile '~/.gitignore'
Windows cmd:

git config --global core.excludesFile "%USERPROFILE%\.gitignore"
Windows PowerShell:

git config --global core.excludesFile "$Env:USERPROFILE\.gitignore"
For Windows it set to the location C:\Users\{myusername}\.gitignore. You can verify that the config value is correct by doing:

git config --global core.excludesFile
The result should be the expanded path to your user profile's .gitignore. Ensure that the value does not contain the unexpanded %USERPROFILE% string.

Important: The above commands will only set the location of the ignore file that git will use. The file has to still be manually created in that location and populated with the ignore list. (from muruge's comment)

You can read about the command at https://help.github.com/articles/ignoring-files/#create-a-global-gitignore

share  edit  follow  flag 
edited Jul 26 at 18:56

Paul Razvan Berg
3,37611 gold badge1818 silver badges3232 bronze badges
answered Sep 7 '11 at 14:21

CB Bailey
601k8989 gold badges592592 silver badges
```

===

```text
Although other answers are correct they are setting the global config value whereas there is a default git location for the global git ignore file:

*nix:

~/.config/git/ignore
Windows:

%USERPROFILE%\git\ignore
You may need to create git directory and ignore file but then you can put your global ignores into that file and that's it!

Source

Which file to place a pattern in depends on how the pattern is meant to be used.

…

Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user’s editor of choice) generally go into a file specified by core.excludesFile in the user’s ~/.gitconfig. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.
share  edit  follow  flag 
edited Nov 4 '16 at 17:01
answered Apr 5 '14 at 19:52

Steve Jorgensen
9,21911 gold badge2929 silver badges37
```

===

> References
>
> <http://egorsmirnov.me/2015/05/04/global-gitignore-file.html>
>
> <https://gist.github.com/octocat/9257657>

---

||| How do I undo the most recent local commits in Git?

> References
> <https://stackoverflow.com/questions/927358/how-do-i-undo-the-most-recent-local-commits-in-git>

```text
Undo a commit and redo

$ git commit -m "Something terribly misguided"             # (1)
$ git reset HEAD~                                          # (2)

<< edit files as necessary >>                              # (3)

$ git add ...                                              # (4)
$ git commit -c ORIG_HEAD                                  # (5)

This is what you want to undo.
This does nothing to your working tree (the state of your files on disk), but undoes the commit and leaves the changes you committed unstaged (so they'll appear as "Changes not staged for commit" in git status, so you'll need to add them again before committing). If you only want to add more changes to the previous commit, or change the commit message1, you could use git reset --soft HEAD~ instead, which is like git reset HEAD~2 but leaves your existing changes staged.
Make corrections to working tree files.
git add anything that you want to include in your new commit.
Commit the changes, reusing the old commit message. reset copied the old head to .git/ORIG_HEAD; commit with -c ORIG_HEAD will open an editor, which initially contains the log message from the old commit and allows you to edit it. If you do not need to edit the message, you could use the -C option.
Beware, however, that if you have added any new changes to the index, using commit --amend will add them to your previous commit.

If the code is already pushed to your server and you have permissions to overwrite history (rebase) then:

git push origin master --force
You can also look at this answer:

How can I move HEAD back to a previous location? (Detached head) & Undo commits

The above answer will show you git reflog, which is used to find out what is the SHA-1, which you wish to revert. Once you found the point to which you want to undo to use the sequence of commands as explained above.

1 Note, however, that you don't need to reset to an earlier commit if you just made a mistake in your commit message. The easier option is to git reset (to unstage any changes you've made since) and then git commit --amend, which will open your default commit message editor pre-populated with the last commit message.

2 HEAD~ is the same as HEAD~1. Also, see What is the HEAD in git?. It's helpful if you want to uncommit multiple commits.

share  edit  follow  flag 
edited Mar 26 at 10:33
community wiki
42 revs, 35 users 17%
Mark Amery
480

And if the commit was to the wrong branch, you may git checkout theRightBranch with all the changes stages. As I just had to do. – Frank Shearar Oct 5 '10 at 15:44
496

If you're working in DOS, instead of git reset --soft HEAD^ you'll need to use git reset --soft HEAD~1. The ^ is a continuation character in DOS so it won't work properly. Also, --soft is the default, so you can omit it if you like and just say git reset HEAD~1. – Ryan Lundy Apr 13 '11 at 14:15
124

zsh users might get: zsh: no matches found: HEAD^ - you need to escape ^ i.e. git reset --soft HEAD\^ – tnajdek Feb 21 '13 at 17:47 
9

The answer is not correct if, say by accident, git commit -a was issued when the -a should have been left out. In which case, it's better no leave out the --soft (which will result in --mixed which is the default) and then you can restage the changes you meant to commit. – dmansfield Jul 2 '14 at 21:19 
7

@IcyBrk git add is a command. git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] 	  [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] 	  [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] 	  [--chmod=(+|-)x] [--] [<pathspec>…​] – Ashraf.Shk786 Feb 20 '17 at 17:34
```

===

```text
In these cases, the "reset" command is your best friend:

git reset --soft HEAD~1
Reset will rewind your current HEAD branch to the specified revision. In our example above, we'd like to return to the one before the current revision - effectively making our last commit undone.

Note the --soft flag: this makes sure that the changes in undone revisions are preserved. After running the command, you'll find the changes as uncommitted local modifications in your working copy.

If you don't want to keep these changes, simply use the --hard flag. Be sure to only do this when you're sure you don't need these changes anymore.

git reset --hard HEAD~1
```

===

```text
Undoing a commit is a little scary if you don't know how it works. But it's actually amazingly easy if you do understand.

Say you have this, where C is your HEAD and (F) is the state of your files.

   (F)
A-B-C
    ↑
  master

You want to nuke commit C and never see it again and lose all the changes in locally modified files. You do this:

git reset --hard HEAD~1
The result is:

 (F)
A-B
  ↑
master

Now B is the HEAD. Because you used --hard, your files are reset to their state at commit B.

Ah, but suppose commit C wasn't a disaster, but just a bit off. You want to undo the commit but keep your changes for a bit of editing before you do a better commit. Starting again from here, with C as your HEAD:

   (F)
A-B-C
    ↑
  master

You can do this, leaving off the --hard:

git reset HEAD~1
In this case the result is:

   (F)
A-B-C
  ↑
master

In both cases, HEAD is just a pointer to the latest commit. When you do a git reset HEAD~1, you tell Git to move the HEAD pointer back one commit. But (unless you use --hard) you leave your files as they were. So now git status shows the changes you had checked into C. You haven't lost a thing!

For the lightest touch, you can even undo your commit but leave your files and your index:

git reset --soft HEAD~1
This not only leaves your files alone, it even leaves your index alone. When you do git status, you'll see that the same files are in the index as before. In fact, right after this command, you could do git commit and you'd be redoing the same commit you just had.

One more thing: Suppose you destroy a commit as in the first example, but then discover you needed it after all? Tough luck, right?

Nope, there's still a way to get it back. Type git reflog and you'll see a list of (partial) commit shas (that is, hashes) that you've moved around in. Find the commit you destroyed, and do this:

git checkout -b someNewBranchName shaYouDestroyed
You've now resurrected that commit. Commits don't actually get destroyed in Git for some 90 days, so you can usually go back and rescue one you didn't mean to get rid of.

share  edit  follow  flag 
edited Feb 3 at 14:49

Mikko Rantalainen
8,27477 gold badges4747 silver badges7575 bronze badges
answered Jul 28 '11 at 22:22

Ryan Lundy
180k3232 gold badges169169 silver badges203203 bronze badges
21

BEWARE! This might not do what you expect if your erroneous commit was a (fast-forward) merge! If your head is on a merge commit (ex: merged branch feature into master), git reset --hard~1 will point the master branch to the last commit inside the feature branch. In this case the specific commit ID should be used instead of the relative command. – Chris Kerekes Feb 20 '13 at 18:46 
100

Missing a crucial point: If the said commit was previously 'pushed' to the remote, any 'undo' operation, no matter how simple, will cause enormous pain and suffering to the rest of the users who have this commit in their local copy, when they do a 'git pull' in the future. So, if the commit was already 'pushed', do this instead: git revert <bad-commit-sha1-id> git push origin : – FractalSpace Nov 8 '13 at 23:43 
15

@FractalSpace, it won't cause "enormous pain and suffering." I've done a few force pushes when using Git with a team. All it takes is communication. – Ryan Lundy Nov 9 '13 at 0:00
15

@Kyralessa In my workplace, messing up entire team's workflow and then telling them how to fix sh*t is not called 'communication'. git history re-write is a destructive operation that results in trashing of parts of the repo. Insisting on its use, while clear and safe alternatives are available is simply irresponsible. – FractalSpace Nov 9 '13 at 3:02
15

I wanted to nuke a commit and never see it again. I used your example with --hard but what I didn't realise is that all my unstaged changes in my working tree also get nuked! I was going to commit these files as part of a later commit. Now it seems impossible to get these files back - I even tried the solution you posted about reflog but this didn't restore the previously-unstaged changes. – Adam Burley Oct 14 '15 at 21:39
```

---

||| Why is my git repository so big?

||| How to remove unused objects from a git repository?

||| Reduce git repository size

||| How to shrink the .git folder

||| Keep your git directory clean with `git clean` and `git trash`

> References
> <https://stackoverflow.com/questions/5277467/how-can-i-clean-my-git-folder-cleaned-up-my-project-directory-but-git-is-sti>

```bash
If you added the files and then removed them, the blobs still exist but are dangling. git fsck will list unreachable blobs, and git prune will delete them.

If you added the files, committed them, and then rolled back with git reset --hard HEAD^, they’re stuck a little deeper. git fsck will not list any dangling commits or blobs, because your branch’s reflog is holding onto them. Here’s one way to ensure that only objects which are in your history proper will remain:

git reflog expire --expire=now --all
git repack -ad  # Remove dangling objects from packfiles
git prune       # Remove dangling loose objects

Another way is also to clone the repository, as that will only carry the objects which are reachable. However, if the dangling objects got packed (and if you performed many operations, git may well have packed automatically), then a local clone will carry the entire packfile:

git clone foo bar                 # bad
git clone --no-hardlinks foo bar  # also bad

You must specify a protocol to force git to compute a new pack:

git clone file://foo bar  # good
```

> References
> <https://stackoverflow.com/questions/5613345/how-to-shrink-the-git-folder>

```bash
you should not delete all changes older than 30 days (i think it's somehow possible exploiting git, but really not recommended).

you can call

git gc --aggressive --prune

, which will perform garbage collection in your repository and prune old objects. do you have a lot of binary files (archives, images, executables) which change often? those usually lead to huge .git folders (remember, git stores snapshots for each revision and binary files compress badly)

--

Actually, git gc --aggressive is considered to be bad practice. It's better to use git repack -a -d --depth=250 --window=250.

```

> References
> <https://stackoverflow.com/questions/2116778/reduce-git-repository-size>

```bash
git gc --aggressive is one way to force the prune process to take place (to be sure: git gc --aggressive --prune=now). You have other commands to clean the repo too. Don't forget though, sometimes git gc alone can increase the size of the repo!

It can be also used after a filter-branch, to mark some directories to be removed from the history (with a further gain of space); see here. But that means nobody is pulling from your public repo. filter-branch can keep backup refs in .git/refs/original, so that directory can be cleaned too.

Finally, as mentioned in this comment and this question; cleaning the reflog can help:

git reflog expire --all --expire=now
git gc --prune=now --aggressive

An even more complete, and possibly dangerous, solution is [to remove unused objects from a git repository](https://stackoverflow.com/questions/3797907/how-to-remove-unused-objects-from-a-git-repository/14729486#14729486)

--

In my case, I pushed several big (> 100Mb) files and then proceeded to remove them. But they were still in the history of my repo, so I had to remove them from it as well.

What did the trick was:

bfg -b 100M  # To remove all blobs from history, whose size is superior to 100Mb
git reflog expire --expire=now --all
git gc --prune=now --aggressive
Then, you need to push force on your branch:

git push origin <your_branch_name> --force
Note: bfg is a tool that can be installed on Linux and macOS using brew:

brew install bfg
```

> References
> <https://stackoverflow.com/questions/3797907/how-to-remove-unused-objects-from-a-git-repository/14729486#14729486>

```bash
I answered this elsewhere, and will copy here since I'm proud of it!

... and without further ado, may I present to you this useful script, git-gc-all, guaranteed to remove all your git garbage until they might come up with extra config variables:

git -c gc.reflogExpire=0 -c gc.reflogExpireUnreachable=0 \
  -c gc.rerereresolved=0 -c gc.rerereunresolved=0 \
  -c gc.pruneExpire=now gc "$@"
The --aggressive option might be helpful.

NOTE: this will remove ALL unreferenced thingies, so don't come crying to me if you decide later that you wanted to keep some of them!

You might also need to run something like these first, oh dear, git is complicated!!

git remote rm origin
rm -rf .git/refs/original/ .git/refs/remotes/ .git/*_HEAD .git/logs/
git for-each-ref --format="%(refname)" refs/original/ |
  xargs -n1 --no-run-if-empty git update-ref -d
I put all this in a script, here:

http://sam.nipl.net/b/git-gc-all-ferocious
```

> References
> <https://stackoverflow.com/questions/1029969/why-is-my-git-repository-so-big>

```bash

I recently pulled the wrong remote repository into the local one (git remote add ... and git remote update). After deleting the unwanted remote ref, branches and tags I still had 1.4GB (!) of wasted space in my repository. I was only able to get rid of this by cloning it with git clone file:///path/to/repository. Note that the file:// makes a world of difference when cloning a local repository - only the referenced objects are copied across, not the whole directory structure.

Edit: Here's Ian's one liner for recreating all branches in the new repo:

d1=#original repo
d2=#new repo (must already exist)
cd $d1
for b in $(git branch | cut -c 3-)
do
    git checkout $b
    x=$(git rev-parse HEAD)
    cd $d2
    git checkout -b $b $x
    cd $d1
done
```

> References
> <https://coderwall.com/p/g16jpq/keep-your-git-directory-clean-with-git-clean-and-git-trash>

---

## git aliases

|||git aliases

```bash
  l = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -n 10
  ll = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -n 20
  lll = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
  la = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all
```

## git autosquash

```bash
$ cat /Users/[user]/bin/git_autosquash_branch_fixups.sh
#!/bin/bash

export current_branch=$(git rev-parse --abbrev-ref HEAD)
export number_of_commits=$(git log master..$current_branch --pretty=oneline | wc -l | sed 's/ //g')

git rebase -i HEAD~$number_of_commits --autosquash
new messages
`  fcommit = commit --fixup
```

---
